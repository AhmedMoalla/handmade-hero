# Day 4: Animating the Backbuffer

> __TLDR__: fill a `bitmapMemory` DIB allocated using `VirtualAlloc` with pixels then copy it to the screen
> DIB using `StretchDIBits`.

- Used another strategy to fill the window DIB[^1] using `StretchDIBits`.
- When `WM_SIZE` occurs, a memory buffer (`bitmapMemory`) is allocated using `VirtualAlloc`.
  - The memory is always correctly sized with the new width and height after every resize.
  - Every time a resize occurs, the `bitmapMemory` is freed using `VirtualFree` and reallocated with the new window _client rect_ size.
  - Notice the `biHeight` of the `BITMAPINFO` struct is negative. That indicates that the `bitmapMemory` is going to represent the pixels starting from the top-left of the screen.

- After filling the `bitmapMemory` buffer with the pixels, `Win32UpdateWindow` is called to copy the built DIB[^1] to the screen DIB[^1] which effectively updates what the screen shows to what was specified in the `bitmapMemory` DIB[^1].

- The window must be updated is case the `WM_PAINT` occurs or when the `bitmapMemory` is to be displayed.

- The message loop was changed from using `GetMessage` to `PeekMessage` to prevent the loop from blocking.
  - Now the loop just consumes all messages from the queue if they exist without blocking.

- An example of rendering some gradient to the windows is defined in `RenderWeirdGradient`.
  - __IMPORTANT__: After rendering, call `Win32UpdateWindow` to copy the `bitmapMemory` DIB[^1] to the screen DIB[^1]

[^1]: Device Independent Bitmap
