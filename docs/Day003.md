# Day 3: Allocating a Backbuffer

- Added some aliases for `static` to be more specific about what it does:
  - `internal` for functions local to the translation unit.
  - `local_persist` for locally scoped static variables.
  - `global_variable` for global static variables.

- Handled `WM_CLOSE` and `WM_DESTROY` by setting a global `running` variable to `false` which is now used as a condition for the window message loop.

- Handled `WM_SIZE` in `Win32ResizeDIBSection` by creating a DIB[^1] section that will be used to render pixels to the screen
  - `CreateDIBSection` is used to create the DIB[^1] section using a `BITMAPINFO` struct that defines the characteristics of the DIB[^1].

  - The width and height of the '_client rect_' of the window are needed to create a DIB[1^] section which dimensions match with those of the window.
  - The '_client rect_' is the part of the window that is the rendering target, excluding the window border.
  - `GetClientRect` is used to get the '_client rect_'.

  - For every `WM_SIZE` event, a new DIB[^1] is recreated with the new dimensions and the older one destroyed with `DeleteObject`.

  - The `CreateDIBSection` function takes a device context which is not available here. `CreateCompatibleDC` is used to ask Windows to provide a device context compatible with the window.
  - The device context is stored in a global `bitmapDeviceContext` variable as is needed to render to the DIB[^1].

  - The `BITMAPINFO` struct is reused through all resize event. `biBitCount` is set to `32` so it can handle four 8-bit values for colors (RGB + padding).

- Handled `WM_PAINT` in `Win32UpdateWindow` by calling `StretchDIBits` between `BeginPaint` and `EndPaint`.
  - `StretchDIBits` will copy the color data for pixels in a DIB[^1] to another destination on the window.
  - The copy is done to the same coordinates to override the old content with the new one.

[^1]: Device Independent Bitmap
